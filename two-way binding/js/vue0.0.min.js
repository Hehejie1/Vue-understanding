


// 观察者模式 发布订阅模式
class Dep {
    constructor(){
        this.subs = []  // 存放所有的watcher
    }
    // 订阅
    addSub(watcher){
        this.subs.push(watcher)
    }
    // 发布
    notify(){
        this.subs.forEach(watcher =>{
            watcher.update()
        })
    }
}

class Watcher {
    constructor(vm, expr, cb){
        this.vm = vm;
        this.expr = expr;
        this.cb = cb;
        this.oldVal = this.get()
    }
    get(){
        Dep.target = this;
        let value = CompileUtil.getVal(this.vm, this.expr);
        Dep.target = null;
        return value
    }
    update(){
        let newVal = CompileUtil.getVal(this.vm, this.expr);
        if (newVal !== this.oldVal){
            this.cb(newVal)
        }
    }

}

// 数据劫持  监听数据变化
class Observe {
    constructor(vm){
        let data = vm.$data;
        this.observer(data)
    }
    observer(data){
        if (data && typeof data == 'object'){
            for (let key in data){
                this.defineRecte(data, key, data[key])
            }
        }
    }
    defineRecte(obj,key,value){
        this.observer(value);
        let dep = new Dep();
        Object.defineProperty(obj,key,{
            get(){
                Dep.target && dep.addSub(Dep.target)
                return value;
            },
            set: (newVal) =>{
                if (newVal != value){
                    this.observer(newVal)
                    value = newVal;
                    dep.notify();
                }
            }
        })
    }

}

// 编译器
class Compiler{
    constructor(el,vm){
        // 判断el是否元素
        this.el = this.isElementNode(el) ? el : document.querySelector(el);
        this.vm = vm;
        // 将里面的内容放在内存中进行统一操作
        let frame = this.nodeToFrame(this.el);
        // 编译数据
        frame = this.complie(frame)
        // 将内容进行放回去
        this.el.appendChild(frame)
    }
    // 遇到对象时候
    complieElement(node){
        let attrs = [...node.attributes];
        attrs.forEach(attr => {
            let {name, value} = attr;
            /*
             * 封装，
             *    1.对于参数而言都需要识别多字段进行分割获取数据
             *
             */
            // v-model
            if (name == 'v-model'){
                new Watcher(this.vm, value, (newVal) => {
                    node.value = newVal;
                })
                // 绑定事件
                node.addEventListener('input', (e) => {
                    CompileUtil.setVal(this.vm, value, e.target.value)
                })
                node.value = CompileUtil.getVal(this.vm, value);
            }
            // v-html
            else if (name == 'v-html'){
                node.innerHTML = CompileUtil.getVal(this.vm, value);
            }
            // v-text
            else if (name == 'v-text'){
                node.innerText = CompileUtil.getVal(this.vm, value);
            }
            // v-if
            else if (name == 'v-if'){
                node.style.display = CompileUtil.getVal(this.vm, value) ? " " : "none";
            }
            // v-show
            else if (name == 'v-show'){
                node.style.visibility = CompileUtil.getVal(this.vm, value) ? "visible" : "none";
            }
            // v-hidden
            else if (name == 'v-if'){
                node.style.visibility = CompileUtil.getVal(this.vm, value) ? "none" : "visible";
            }
            // v-on
            else if (name.startsWith('v-on')){
                let [,event] = name.split(":");
                node.addEventListener(event,(e) => {
                    this.vm[value].call(this.vm,e)
                })
            }


        })
    }
    // 遇到文本时候
    complieText(node){
        let content = node.textContent;
        if (/\{\{(.+?)\}\}/.test(content)){
            CompileUtil.text(node, content, this.vm)
        }
    }
    // 核心编译代码
    complie(node){
        let childs = [...node.childNodes];

        childs.forEach(child => {
            if (this.isElementNode(child)){
                this.complieElement(child)
                // 如果是元素再进行编译
                this.complie(child)
            } else{
                this.complieText(child)
            }
        })
        return node
    }
    // 创建虚拟节点对象
    nodeToFrame(node){
        let frame = document.createDocumentFragment()
        let firshChild;
        while (firshChild = node.firstChild){
            frame.appendChild(firshChild);
        }
        return frame;
    }
    // 判断是否为元素节点
    isElementNode(node){
        return node.nodeType === 1
    }
}
// 编译工具类
CompileUtil = {
    // 获取参数的值
    getVal(vm, expr){
        if (typeof expr != 'string'){
            return ''
        }
        let values = expr.split('.');
        // 使用类指针方法
        // let i = 0;
        // let data = this.vm.$data;
        // while (i < values.length){
        //     data = data[values[i]] ? data[values[i]] : undefined
        //     i++;
        // }
        // return data


        // 使用reduce方法
        return values.reduce((datas, current) => {
            return datas[current] ? datas[current] : ''
        }, vm.$data)
    },
    // 设置表达式的值
    setVal(vm, expr, value){
        if (typeof expr != 'string'){
            return ''
        }
        expr.split('.').reduce((datas, current, index, arr) => {
            if (index == arr.length - 1){
                datas[current] = value;
            }
            return datas[current]
        }, vm.$data)
    },
    getContent(vm, expr){
        return expr.replace(/\{\{(.+?)\}\}/g, (...args) => {
            return CompileUtil.getVal(vm, args[1]);
        });
    },
    /*
    * 如果这里没有放在这里保存，则这里面的expr将会被node刷新成数据，丢失了原本的模板，所以造成无法刷新
    *
    */
    text(node, expr, vm){
        node.textContent = expr.replace(/\{\{(.+?)\}\}/g, (...args) => {
            // 在第一次创建文本时候进行监听事件
            new Watcher(vm, args[1], (newVal) => {
                console.log(expr);
                node.textContent =  this.getContent(vm, expr);
            })
            return CompileUtil.getVal(vm, args[1]);
        })
    }
}

// Vue
class Vue {
    constructor(options){
        this.$el = options.el;
        this.$data = options.data;
        let computed = options.computed;
        let methods = options.methods;

        if (this.$el){
            // 监听数据变化
            new Observe(this);

            // 绑定计算值
            for (let key in computed){
                Object.defineProperty(this.$data , key, {
                    get:() => {
                        return computed[key].call(this)
                    }
                })
            }
            // 绑定事件
            for (let key in methods){
                Object.defineProperty(this , key, {
                    get(){
                        return methods[key]
                    }
                })
            }

            // 代理： 将vm.$data的取值放到vm上
            this.proxyVM(this.$data);

            // 编译模板
            new Compiler(this.$el, this);
        }
    }
    proxyVM(data){
        for (let key in data){
            Object.defineProperty(this,key,{
                get(){
                    return data[key];
                }
            })
        }
    }
}